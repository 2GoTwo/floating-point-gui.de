--- 
title: Rounding Errors
---

Both decimal and binary (and any other base as well) can represent only those fractions in a 
finite positional notation where the denominator of the fraction has only prime factors that 
also occur in the base. For example, in decimal 1/4, 3/5 and 8/20 are finite, because 2 and 
5 are the prime factors of 10. But 1/3 is not finite, nor is 2/3 or 1/7 or 4/6, because 3 
and 7 are not factors of 10.

Similarly, in binary only those fractions are finite that are a (finite) sum of negative
powers of two. Unfortunately, this does not include most of the numbers that can be 
represented as finite fration in base 10, like 0.1 - and there you are. Since computer 
memory is limited, infinite fractions have to be cut off after some point:

| Fraction | Base | Positional Notation | Rounded to 4 digits| Rounded value as fraction | Rounding error |
|-|-|-|-|
| 1/10 | 10 | 0.1 | 0.1 | 1/10 | 0 |
| 1/3  | 10 | 0.<span class="over">3</span> | 0.3333 | 3333/10000 | 1/30000 |
| 1/2  | 2  | 0.1 | 0.1 | 1/2 | 0 |
| 1/10 | 2  | 0.<span class="over">00011</span> | 0.0001 | 1/16 | 3/80 |

And this is how you already get a rounding error when you just *write down* a number like 0.1 and
run it through your interpreter or compiler. It's not as big as 3/80 and may be invisible because
computers cut off after 23 or 52 binary digits rather than 4. Which leads us to the next concept...

